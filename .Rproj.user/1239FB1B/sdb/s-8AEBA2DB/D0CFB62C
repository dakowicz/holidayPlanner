{
    "collab_server" : "",
    "contents" : "library(plyr)\nlibrary(dplyr)\n\nweather <- read.csv(file = \"weather.csv\")\nflightCost <- read.csv(file = \"flightCost.csv\")\nhotelCost <- read.csv(file = \"hotelCost.csv\")\ncities <- read.csv(file = \"cities.csv\")\n\nM <- 1\n\ngetFlightCost <- function(cityA, cityB) {\n  return(flightCost %>% \n           filter((cityStart == cityA & cityDest == cityB) | (cityStart == cityB & cityDest == cityA)) %>% \n           select(flightCost))\n}\n\ngetHotelCost <- function(cityH) {\n  return(hotelCost %>% \n           filter(city == cityH) %>% \n           select(hotelCost))\n}\n\ngetWeather <- function(cityW, dayNum) {\n  return(weather %>% \n           filter(city == cityW, DayNum == dayNum) %>% \n           select(weather))\n}\n\ngetTotalCost <- function(cityStart, cityDest) {\n  return(getFlightCost(cityStart, cityDest) + getHotelCost(cityDest))\n}\n\ncomputeTarget <- function(cStart, cDest, dayNr) {\n  action <- getTotalCost(cStart, cDest)\n  weatherForCity <- getWeather(cDest, dayNr)\n  return(action*(1/weatherForCity)*M)\n}\n\nprepareNodes <- function() {\n  return(ddply(weather, .(city, DayNum), function(x) {\n    data.frame(\n      city = x$city,\n      dayNum = x$DayNum\n    )\n  }) %>% select(city,dayNum) %>% arrange(dayNum))\n}\n\nconstructGraph <- function(nodeSet) {\n  return(ddply(nodeSet, .(city, dayNum), function(x) {\n    ddply((nodeSet %>% filter(dayNum == x$dayNum + 1)), .(city, dayNum), function(y) {\n      data.frame(\n        nodeStart = x,\n        nodeDest = y,\n        gScore = computeTarget(x$city, y$city, y$dayNum)$flightCost\n      )\n    })\n  })) %>% select(nodeStart.city, nodeStart.dayNum, nodeDest.city, nodeDest.dayNum, gScore)\n}\n\ngetFirstN <- function(set, n) {\n  return(set %>% arrange(gScore) %>% slice(1:n))\n}\n\nstartState <- function(nodes) {\n  return(ddply((nodes %>% filter(city == \"start\", dayNum == 0)), .(city, dayNum, hScore), function(x) {\n    data.frame(\n      prevCity = \"start\",\n      gScore = 0 \n    )\n  }))\n}\n\nfindBest <- function(set) {\n  return(set %>%\n           slice(which.min(gScore + hScore)))\n}\n\ngetAvailableEdges <- function(node, edges) {\n  return(edges %>%\n           filter(nodeStart.dayNum > node$dayNum | nodeStart.dayNum == node$dayNum & nodeStart.city == node$city)\n  )\n}\n\naddhScore <- function(nodes, edges, targetDayNum) {\n  return(ddply(nodes, .(city, dayNum), function(x){\n    available <- getAvailableEdges(x, edges)\n    data.frame(\n      hScore = sum(getFirstN(available, targetDayNum - x$dayNum)$gScore)\n    )\n  }))\n}\n\naddStates <- function(set, state) {\n  return(rbind(set, state))\n}\n\nremoveState <- function(set, state) {\n  return(set[!(set$city == state$city\n               & set$prevCity == state$prevCity\n               & set$dayNum == state$dayNum\n               & set$hScore == state$hScore\n               & set$gScore == state$gScore),])\n}\n\nexists <- function(set, state) {\n  return(tail(duplicated(rbind(set,state)),1))\n}\n\nexistsByCityAndDayNum <- function(set, stateR) {\n  return(set %>% filter(city == stateR$city & dayNum == stateR$dayNum))\n}\n\ncreateNewState <- function(currState, nextCity, gScore, nodes) {\n  return(\n    data.frame(\n      city = nextCity,\n      prevCity = currState$city,\n      dayNum = currState$dayNum + 1,\n      gScore = currState$gScore + gScore,\n      hScore = 0\n    )\n  )\n}\n\nexpandState <- function(curr, nodes, edges) {\n  neighbours <- edges %>% \n    filter(nodeStart.city == curr$city, nodeStart.dayNum == curr$dayNum)\n  if(nrow(neighbours) == 0) {\n    return(NULL)\n  }\n  return(ddply(neighbours, .(nodeStart.city, nodeStart.dayNum, nodeDest.city, nodeDest.dayNum, gScore), function(x) {\n    data.frame(\n      city = x$nodeDest.city,\n      prevCity = curr$city,\n      dayNum = x$nodeDest.dayNum,\n      gScore = curr$gScore + x$gScore,\n      hScore = (nodes %>% filter(city == x$nodeDest.city, dayNum == x$nodeDest.dayNum))$hScore\n    )\n  }) %>% select(city, prevCity, dayNum, gScore, hScore))\n}\n\nfindOpenStates <- function(openSet, closedSet, newStates) {\n  return(ddply(newStates, .(city, prevCity, dayNum, gScore, hScore), function(x) {\n    if(nrow(existsByCityAndDayNum(closedSet, x)) == 0) {\n      return(x)\n    }\n  }))\n}\n\nupdateSet <- function(set, states) {\n  return(ddply(set, .(city, prevCity, dayNum, gScore, hScore), function(x){\n    occurence <- existsByCityAndDayNum(states, x)\n    if(nrow(occurence) == 0) {\n      return(x)\n    } else {\n      if((x$gScore + x$hScore) > (occurence$gScore + occurence$hScore)) {\n        return(occurence)\n      }\n    }\n  }))\n}\n\ngetNewStates <- function(set, states) {\n  return(ddply(states, .(city, prevCity, dayNum, gScore, hScore), function(x) {\n    occurence <- existsByCityAndDayNum(set, x)\n    if(nrow(occurence) == 0) {\n      return(x)\n  }}))\n}\n\nmergeStates <- function(set, states) {\n  if(is.null(states)) {\n    return(set)\n  }\n  #update\n  set <- updateSet(set, states)\n  #add new\n  return(addStates(set, getNewStates(set, states)))\n}\n\ngetResult <- function(set, targetDayNum) {\n  return(set %>% \n           filter(city == \"start\", dayNum == targetDayNum) %>%\n           slice(which.min(gScore)))\n}\n\nrunAStar <- function(targetDayNum) {\n  nodes <- prepareNodes()\n  edges <- constructGraph(nodes)\n  nodes <- addhScore(nodes, edges, targetDayNum)\n  \n  closedSet <- NULL\n  openSet <- startState(nodes)\n  \n  while(nrow(openSet) != 0) {\n    curr <- findBest(openSet)\n\n    closedSet <- addStates(closedSet, curr)\n    openSet <- removeState(openSet, curr)\n\n    newStates <- expandState(curr, nodes, edges)\n    openStates <- findOpenStates(openSet, closedSet, newStates)\n    openSet <- mergeStates(openSet, openStates)\n  }\n\n  return(getResult(closedSet, targetDayNum))\n}",
    "created" : 1485484662032.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1334806831",
    "id" : "D0CFB62C",
    "lastKnownWriteTime" : 1485484535,
    "last_content_update" : 1485484535,
    "path" : "D:/programming/alhe/urlop/A_Star.R",
    "project_path" : "A_Star.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}